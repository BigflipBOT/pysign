import base64
import argparse
from argparse import RawTextHelpFormatter
import cryptography
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes # easier to use this here than hashlib
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.serialization import load_pem_public_key

def savekeypair(pub_bytes, priv_bytes, keyname):
    with open(keyname+".priv.pem", "wb") as f:
        f.write(priv_bytes)

    with open(keyname+".pub.pem", "wb") as f:
        f.write(pub_bytes)

    print("keyfiles saved")
    
def genkeypair(keyname): # generating public and ptivate key
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048) # high public_exponent 
    priv_bytes = private_key.private_bytes(                                      # because of a lack of padding
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption())
        
    public_key = private_key.public_key()
    pub_bytes = public_key.public_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    print("keys generated")
    print(pub_bytes.decode("utf-8")) # displaying pub key for convinience 
    # and not displaying priv key because displaying it is not convinient
    savekeypair(pub_bytes, priv_bytes, keyname) # saving keys as files
    return (private_key, public_key)

def load_private_key(keyname):
    with open(keyname + ".priv.pem", "rb") as f:
        priv_bytes = f.read()
        private_key = serialization.load_pem_private_key(
            priv_bytes,
            password=None,
        )
    return private_key

def load_public_key(keyname):
    with open(keyname + ".pub.pem", "rb") as f:
        pub_bytes = f.read()
        public_key = serialization.load_pem_public_key(pub_bytes)
    return public_key

def sign(message, private_key):
    signature = private_key.sign( # creating a file signature
            message,
            padding.PKCS1v15(), 
            hashes.SHA256()
        )
    print("signed succesfully")
    return base64.b64encode(signature)

def verify(message, signature, public_key):
    sig = base64.b64decode(signature)
    try:
        public_key.verify(
            sig,
            message,
            padding.PKCS1v15(), 
            hashes.SHA256()
        )
        return True # true if file is signed with that key...
    except cryptography.exceptions.InvalidSignature:
        return False # and false if it isn't

if __name__ == "__main__":
    praser = argparse.ArgumentParser(
        prog='pysign',
        description='program used to sign and verify files with rsa.\
        it is also capable of generating keypair',
        epilog='example usage: python pysign.py secret.txt key -v secret.txt.sig'
    )
    praser.add_argument('filename', nargs=1, type=str,
                        help='file to sign')
    praser.add_argument('keyname', nargs=1,
                        help=
                        'keyname is an argument that usage differs with diffrent flags:\n\
                        --sign\t-> private key to sign with;\n\
                        --verify\t-> public key to verify with;\n\
                        --genkey\t-> name of the keyfile to generate;\n\
                        keyname param should be provided with no extensions. program will choose wchitch to use itself',
                        # formatter_class=argparse.RawTextHelpFormatter
    )
    praser.add_argument('-v', '--verify', nargs=1, 
                        help='verify file providing rsa public key and .sig file here.')
    praser.add_argument('-s', '--sign', action='store_true',
                        help='sign file with provided key or with a autogenerated key.')
    praser.add_argument('-g', '--genkey', action='store_true',
                        help='generate rsa keypair to sign the file with.\n \
                         \ncan only be used with --sign.')
    # praser.add_argument('-k', '--key', nargs=1, help='provide rsa key')

    # exceptions handling
    args = praser.parse_args()
    if (args.verify is not None) and args.sign:
        print("error: bad_usage: you can't sign and verify at the same time!")
        exit(-1)

    if args.verify and args.genkey:
        print("error: bad_usage: you can't verify and genkey at the same time!")
        exit(-1)

    # main program execution

    private_key, public_key = "", ""
    
    if args.genkey:
        private_key, public_key = genkeypair(args.keyname[0]) # generate and save keypair
    else:
        if args.sign:
            private_key = load_private_key(args.keyname[0])
        elif args.verify is not None:
            public_key = load_public_key(args.keyname[0])

    if args.sign:
        with open(args.filename[0], "rb") as f:
            with open(args.filename[0]+".sig", "wb") as fsig:
                fsig.write(sign(f.read(), private_key)) # generating a signature file

    if args.verify is not None:
        with open(args.filename[0], "rb") as f:
            with open(args.verify[0], "rb") as fsig:
                if verify(f.read(), fsig.read(), public_key):
                    print("verification completed! file is signed with that key")
                else:
                    print("verification failed! file is not signed with that key")


    exit(0)
